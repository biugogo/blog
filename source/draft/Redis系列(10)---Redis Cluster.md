# Redis系列(10)---Redis Cluster

## Redis Cluster能带来什么
1. 高可用性和高达1000个节点的线性扩展能力，不使用代理，异步复制，数据无合并
2. 可接受的写入安全性。把数据丢失控制在一个可接受的时间窗口
3. 自动的故障转移能力，在大多数节点可用，并且故障节点拥有备份节点时。同时支持*replicas migration*：自己没有Slave时，向其他有多个Slave的节点借取Slave的能力。


## Redis Cluster端口
Redis Cluster的每个node需要占用两个端口。默认6379和16379（前一个节点加10000）.6379用于客户端通信，16379 bus端口用于集群内部通信（点对点二进制通信端口，用于失败检测，配置更新，故障转移等）。如果bus端口不可用，Redis Cluster无法进行故障转移等功能。


## 分片规则
Redis Cluster不是使用一致性hash，而是使用hash slot---哈希槽。
### 普通hash、consistent hash(一致性hash)和hash slot（哈希槽）差别
1. 普通hash：hash计算的值，跟你想要key被hash到的节点数量是相关想。当节点数量发生变化，同一key的hash值会发生变化。例子：把int64的uid分配到5台机器上，选择uid%5来分配，机器变化为6台时，hash算法变为uid%6。hash值发生变化。

2. 一致性hash：节点变化不会影响key的hash值。
    * 构建一个哈希环（hash ring）（2的32次方-1）
    * 计算缓存对象的哈希值放入
    * 计算缓存节点（ip或者主机名）的哈希值放入
    * 从缓存对象所在的位置顺时针查找最近的缓存节点位置
    * **缺点**： 一致性哈希算法无法满足平衡性，所以需要引入虚拟节点的概念，通过为缓存节点创建N个虚拟节点（例如为ip或者主机名加上%N后缀），使缓存对象更均匀的分布在哈希环上。
3. hash slot：先规划好slot个数，hash会分配到slot上，不同主机分配不同slot范围。通过预先规划和变动槽对应的缓存节点，就能满足单调性和平衡性。
    * 规划槽的数量（常见1024（codis）或者16383（redis-cluster））
    * 每个槽对应一个可重复的缓存节点

### 具体算法
1. 对Key使用CRC16求校验码
2. slot  = 校验码 %16384来计算键key属于哪个slot
3. 查看slot属于哪个节点

### 为什么是16384

我们知道，Redis Cluster无时无刻都在相互发送心跳包。

* 每秒会随机选取5个节点，找出最久没有通信的节点发送ping消息
* 每100毫秒(1秒10次)都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster-node-timeout/2 则立刻发送ping消息

心跳的频繁程度，间接的导致Redis Cluster的节点数量不会太多，一般不超过1000。否则，集群中会充斥着大量的心跳信息，占用大量带宽降低集群性能。
<br>
占用最大结构是心跳包中有一个char数组组成的bitmap结构：
![心跳包结构](https://makefriends.bs2dl.yy.com/bm1577605736141.png)

当bitmap被置为1时，表示节点持有这个槽。假如分配65536个槽，我们需要65536位来表示槽信息，65536位=8192b=8kb。我们按照常理基本只有1000个节点，不需要slot数量太大。
所以选择 16384位=2048B=2Kb的数据结构，同时CRC16计算的值也会均匀的分布在16384个槽中。所以选择16384是在网络带宽以及Redis Cluster节点数的双重背景下，选择的一个比较折中的值。


## 一致性问题
和Sentinal一样，Redis Cluster无法保证数据强一致性（写入数据不丢失）。原因有2：
1. Master-Slave同步带来的同步数据丢失
    * Client写入Master成功，返回OK
    * Master还未成功同步写入数据给Slave，Master挂掉
    * Slave成为新的Master，丢失刚刚写的数据

2. 网络分区孤立带来的集群脑裂数据丢失
    * 有A,B,C,A1,B1,C1 6个节点，3主3备结构的Redis Cluster集群
    * 发生网路分区不可通信，A,C,A1,B1,C1 在一个分区，B被隔离到另一个分区。
    * Client继续像B写入消息，同时收到OK
    * B1成为了新Master，写入B的消息丢失。


